/* tslint:disable */
/* eslint-disable */
/**
 * ğŸªœ
 * ğŸªœé¡¹ç›®çš„API
 *
 * The version of the OpenAPI document: 3.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * åœ°å€
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    City?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    Detail?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    District?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    Province?: string;
}
/**
 * 
 * @export
 * @interface D2ModelCreateRequest
 */
export interface D2ModelCreateRequest {
    /**
     * `binding:\"dive\"`
     * @type {Array<D2ModelCreateRequestItems>}
     * @memberof D2ModelCreateRequest
     */
    Items?: Array<D2ModelCreateRequestItems>;
}
/**
 * 
 * @export
 * @interface D2ModelCreateRequestItems
 */
export interface D2ModelCreateRequestItems {
    /**
     * åç§°. å¯ä»¥è‡ªåŠ¨å–æ–‡ä»¶åç§°, ä½†éœ€è¦å»æ‰æ‰©å±•æ–‡ä»¶å `binding:\"required\"`
     * @type {string}
     * @memberof D2ModelCreateRequestItems
     */
    Name?: string;
    /**
     * ä¸Šä¼ åˆ°OSSçš„è·¯å¾„, ä¸è¦ä¿ç•™åŸŸå `binding:\"required\"`
     * @type {string}
     * @memberof D2ModelCreateRequestItems
     */
    Path?: string;
    /**
     * æˆªé¢åºåˆ—åŒ–åçš„å­—ç¬¦ä¸² `binding:\"required\"`
     * @type {string}
     * @memberof D2ModelCreateRequestItems
     */
    Payload?: string;
    /**
     * é¢„è§ˆå›¾ `binding:\"required\"`
     * @type {string}
     * @memberof D2ModelCreateRequestItems
     */
    Preview?: string;
    /**
     * æ ‡ç­¾ `binding:\"required\"`
     * @type {object}
     * @memberof D2ModelCreateRequestItems
     */
    Tags?: object;
}
/**
 * 
 * @export
 * @interface D2ModelDeleteRequest
 */
export interface D2ModelDeleteRequest {
    /**
     * `binding:\"min=1\"`
     * @type {Array<number>}
     * @memberof D2ModelDeleteRequest
     */
    Ids?: Array<number>;
}
/**
 * 
 * @export
 * @interface D2ModelQueryRequest
 */
export interface D2ModelQueryRequest {
    /**
     * åç§°. æ¨¡ç³ŠæŸ¥è¯¢ `binding:\"omitempty\"`
     * @type {string}
     * @memberof D2ModelQueryRequest
     */
    Name?: string;
    /**
     * æ ‡ç­¾. `binding:\"omitempty\"`
     * @type {object}
     * @memberof D2ModelQueryRequest
     */
    Tags?: object;
}
/**
 * 
 * @export
 * @interface D2ModelUpdateRequest
 */
export interface D2ModelUpdateRequest {
    /**
     * æˆªé¢ID
     * @type {number}
     * @memberof D2ModelUpdateRequest
     */
    ID?: number;
    /**
     * åç§°. å¯ä»¥è‡ªåŠ¨å–æ–‡ä»¶åç§°, ä½†éœ€è¦å»æ‰æ‰©å±•æ–‡ä»¶å
     * @type {string}
     * @memberof D2ModelUpdateRequest
     */
    Name?: string;
    /**
     * æ ‡ç­¾
     * @type {object}
     * @memberof D2ModelUpdateRequest
     */
    Tags?: object;
}
/**
 * 
 * @export
 * @interface D3ModelCreateRequest
 */
export interface D3ModelCreateRequest {
    /**
     * `binding:\"min=1,dive\"`
     * @type {Array<D3ModelCreateRequestItems>}
     * @memberof D3ModelCreateRequest
     */
    Items?: Array<D3ModelCreateRequestItems>;
}
/**
 * 
 * @export
 * @interface D3ModelCreateRequestItems
 */
export interface D3ModelCreateRequestItems {
    /**
     * åç§° `binding:\"required\"`
     * @type {string}
     * @memberof D3ModelCreateRequestItems
     */
    Name?: string;
    /**
     * æ¨¡å‹æ–‡ä»¶ä¸Šä¼ åˆ°OSSåçš„è·¯å¾„ `binding:\"required\"`
     * @type {string}
     * @memberof D3ModelCreateRequestItems
     */
    Path?: string;
    /**
     * æ ‡ç­¾ `binding:\"required\"`
     * @type {object}
     * @memberof D3ModelCreateRequestItems
     */
    Tags?: object;
    /**
     * æ¨¡å‹ç±»å‹ `binding:\"required\"`
     * @type {string}
     * @memberof D3ModelCreateRequestItems
     */
    Type?: D3ModelCreateRequestItemsTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum D3ModelCreateRequestItemsTypeEnum {
    Small = 'column_small',
    Large = 'column_large'
}

/**
 * 
 * @export
 * @interface D3ModelDeleteRequest
 */
export interface D3ModelDeleteRequest {
    /**
     * `binding:\"min=1\"`
     * @type {Array<number>}
     * @memberof D3ModelDeleteRequest
     */
    Ids?: Array<number>;
}
/**
 * 
 * @export
 * @interface D3ModelQueryRequest
 */
export interface D3ModelQueryRequest {
    /**
     * åç§°. æ¨¡ç³ŠæŸ¥è¯¢ `binding:\"omitempty\"`
     * @type {string}
     * @memberof D3ModelQueryRequest
     */
    Name?: string;
    /**
     * æ¸²æŸ“çŠ¶æ€ `binding:\"omitempty\"`
     * @type {Array<string>}
     * @memberof D3ModelQueryRequest
     */
    Status?: Array<D3ModelQueryRequestStatusEnum>;
    /**
     * æ ‡ç­¾. `binding:\"omitempty\"`
     * @type {object}
     * @memberof D3ModelQueryRequest
     */
    Tags?: object;
    /**
     * æ¨¡å‹ç±»å‹ `binding:\"omitempty\"`
     * @type {string}
     * @memberof D3ModelQueryRequest
     */
    Type?: D3ModelQueryRequestTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum D3ModelQueryRequestStatusEnum {
    Waiting = 'waiting',
    Success = 'success',
    Failed = 'failed',
    Created = 'created',
    Rendering = 'rendering',
    Cancel = 'cancel'
}
/**
    * @export
    * @enum {string}
    */
export enum D3ModelQueryRequestTypeEnum {
    Small = 'column_small',
    Large = 'column_large'
}

/**
 * 
 * @export
 * @interface D3ModelUpdateRequest
 */
export interface D3ModelUpdateRequest {
    /**
     * æ¨¡å‹ID
     * @type {number}
     * @memberof D3ModelUpdateRequest
     */
    ID?: number;
    /**
     * åç§°. å¯ä»¥è‡ªåŠ¨å–æ–‡ä»¶åç§°, ä½†éœ€è¦å»æ‰æ‰©å±•æ–‡ä»¶å
     * @type {string}
     * @memberof D3ModelUpdateRequest
     */
    Name?: string;
    /**
     * æ ‡ç­¾
     * @type {object}
     * @memberof D3ModelUpdateRequest
     */
    Tags?: object;
    /**
     * æ¨¡å‹ç±»å‹
     * @type {string}
     * @memberof D3ModelUpdateRequest
     */
    Type?: D3ModelUpdateRequestTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum D3ModelUpdateRequestTypeEnum {
    Small = 'column_small',
    Large = 'column_large'
}

/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    captcha?: string;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    login_type?: LoginLoginTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    phone?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum LoginLoginTypeEnum {
    å¯†ç  = 'å¯†ç ',
    çŸ­ä¿¡ = 'çŸ­ä¿¡'
}

/**
 * 
 * @export
 * @interface MaterialCreateRequest
 */
export interface MaterialCreateRequest {
    /**
     * `binding:\"dive\"`
     * @type {Array<MaterialCreateRequestItems>}
     * @memberof MaterialCreateRequest
     */
    Items?: Array<MaterialCreateRequestItems>;
}
/**
 * 
 * @export
 * @interface MaterialCreateRequestItems
 */
export interface MaterialCreateRequestItems {
    /**
     * é«˜ `binding:\"required\"`
     * @type {number}
     * @memberof MaterialCreateRequestItems
     */
    Height?: number;
    /**
     * åç§°. å¯ä»¥è‡ªåŠ¨å–æ–‡ä»¶åç§°, ä½†éœ€è¦å»æ‰æ‰©å±•æ–‡ä»¶å `binding:\"required\"`
     * @type {string}
     * @memberof MaterialCreateRequestItems
     */
    Name?: string;
    /**
     * ä¸Šä¼ åˆ°OSSçš„è·¯å¾„, ä¸è¦ä¿ç•™åŸŸå `binding:\"required\"`
     * @type {string}
     * @memberof MaterialCreateRequestItems
     */
    Path?: string;
    /**
     * æ ‡ç­¾ `binding:\"required\"`
     * @type {object}
     * @memberof MaterialCreateRequestItems
     */
    Tags?: object;
    /**
     * å®½ `binding:\"required\"`
     * @type {number}
     * @memberof MaterialCreateRequestItems
     */
    Width?: number;
}
/**
 * 
 * @export
 * @interface MaterialDeleteRequest
 */
export interface MaterialDeleteRequest {
    /**
     * `binding:\"min=1\"`
     * @type {Array<number>}
     * @memberof MaterialDeleteRequest
     */
    Ids?: Array<number>;
}
/**
 * 
 * @export
 * @interface MaterialListByNameRequest
 */
export interface MaterialListByNameRequest {
    /**
     * åç§° `binding:\"min=1\"`
     * @type {Array<string>}
     * @memberof MaterialListByNameRequest
     */
    Names?: Array<string>;
}
/**
 * 
 * @export
 * @interface MaterialQueryRequest
 */
export interface MaterialQueryRequest {
    /**
     * åç§°. æ¨¡ç³ŠæŸ¥è¯¢ `binding:\"omitempty\"`
     * @type {string}
     * @memberof MaterialQueryRequest
     */
    Name?: string;
    /**
     * æ ‡ç­¾. `binding:\"omitempty\"`
     * @type {object}
     * @memberof MaterialQueryRequest
     */
    Tags?: object;
}
/**
 * 
 * @export
 * @interface MaterialUpdateRequest
 */
export interface MaterialUpdateRequest {
    /**
     * é«˜
     * @type {number}
     * @memberof MaterialUpdateRequest
     */
    Height?: number;
    /**
     * æè´¨UD
     * @type {number}
     * @memberof MaterialUpdateRequest
     */
    ID?: number;
    /**
     * åç§°. å¯ä»¥è‡ªåŠ¨å–æ–‡ä»¶åç§°, ä½†éœ€è¦å»æ‰æ‰©å±•æ–‡ä»¶å
     * @type {string}
     * @memberof MaterialUpdateRequest
     */
    Name?: string;
    /**
     * æ ‡ç­¾
     * @type {object}
     * @memberof MaterialUpdateRequest
     */
    Tags?: object;
    /**
     * å®½
     * @type {number}
     * @memberof MaterialUpdateRequest
     */
    Width?: number;
}
/**
 * 
 * @export
 * @interface MemberCardCreateRequest
 */
export interface MemberCardCreateRequest {
    /**
     * æŠ˜æ‰£ `binding:\"max=1\"`
     * @type {number}
     * @memberof MemberCardCreateRequest
     */
    Discount?: number;
    /**
     * èµ é€é‡‘é¢ `binding:\"omitempty\"`
     * @type {number}
     * @memberof MemberCardCreateRequest
     */
    GiftAmount?: number;
    /**
     * æœ‰æ•ˆæœŸ
     * @type {number}
     * @memberof MemberCardCreateRequest
     */
    Interval?: number;
    /**
     * åç§°
     * @type {string}
     * @memberof MemberCardCreateRequest
     */
    Name?: string;
    /**
     * ä»·æ ¼
     * @type {number}
     * @memberof MemberCardCreateRequest
     */
    Price?: number;
    /**
     * æœ‰æ•ˆæœŸå•ä½
     * @type {string}
     * @memberof MemberCardCreateRequest
     */
    Unit?: MemberCardCreateRequestUnitEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum MemberCardCreateRequestUnitEnum {
    D = 'D',
    W = 'W',
    M = 'M',
    Y = 'Y'
}

/**
 * 
 * @export
 * @interface MemberCardDeleteRequest
 */
export interface MemberCardDeleteRequest {
    /**
     * ä¼šå‘˜å¡ID
     * @type {number}
     * @memberof MemberCardDeleteRequest
     */
    ID?: number;
}
/**
 * 
 * @export
 * @interface MemberCardQueryRequest
 */
export interface MemberCardQueryRequest {
    /**
     * `binding:\"omitempty\"`
     * @type {string}
     * @memberof MemberCardQueryRequest
     */
    SalesStatus?: MemberCardQueryRequestSalesStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum MemberCardQueryRequestSalesStatusEnum {
    ä¸‹æ¶ = 'ä¸‹æ¶',
    ä¸Šæ¶ = 'ä¸Šæ¶'
}

/**
 * 
 * @export
 * @interface MemberCardUpdateRequest
 */
export interface MemberCardUpdateRequest {
    /**
     * æŠ˜æ‰£ `binding:\"max=1\"`
     * @type {number}
     * @memberof MemberCardUpdateRequest
     */
    Discount?: number;
    /**
     * èµ é€é‡‘é¢ `binding:\"omitempty\"`
     * @type {number}
     * @memberof MemberCardUpdateRequest
     */
    GiftAmount?: number;
    /**
     * ä¼šå‘˜å¡ID
     * @type {number}
     * @memberof MemberCardUpdateRequest
     */
    ID?: number;
    /**
     * æœ‰æ•ˆæœŸ
     * @type {number}
     * @memberof MemberCardUpdateRequest
     */
    Interval?: number;
    /**
     * åç§°
     * @type {string}
     * @memberof MemberCardUpdateRequest
     */
    Name?: string;
    /**
     * ä»·æ ¼
     * @type {number}
     * @memberof MemberCardUpdateRequest
     */
    Price?: number;
    /**
     * æœ‰æ•ˆæœŸå•ä½
     * @type {string}
     * @memberof MemberCardUpdateRequest
     */
    Unit?: MemberCardUpdateRequestUnitEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum MemberCardUpdateRequestUnitEnum {
    D = 'D',
    W = 'W',
    M = 'M',
    Y = 'Y'
}

/**
 * 
 * @export
 * @interface MemberCardUpdateSalesStatusRequest
 */
export interface MemberCardUpdateSalesStatusRequest {
    /**
     * ä¼šå‘˜å¡ID
     * @type {number}
     * @memberof MemberCardUpdateSalesStatusRequest
     */
    ID?: number;
    /**
     * é”€å”®çŠ¶æ€
     * @type {string}
     * @memberof MemberCardUpdateSalesStatusRequest
     */
    SalesStatus?: MemberCardUpdateSalesStatusRequestSalesStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum MemberCardUpdateSalesStatusRequestSalesStatusEnum {
    ä¸‹æ¶ = 'ä¸‹æ¶',
    ä¸Šæ¶ = 'ä¸Šæ¶'
}

/**
 * 
 * @export
 * @interface MemberQueryRequest
 */
export interface MemberQueryRequest {
    /**
     * ç»“æŸæ—¶é—´. æŒ‡æ³¨å†Œ `binding:\"omitempty\"`
     * @type {number}
     * @memberof MemberQueryRequest
     */
    EndTime?: number;
    /**
     * æ˜µç§°. æ¨¡ç³ŠæŸ¥è¯¢ `binding:\"omitempty\"`
     * @type {string}
     * @memberof MemberQueryRequest
     */
    NickName?: string;
    /**
     * ç”µè¯. æ¨¡ç³ŠæŸ¥è¯¢ `binding:\"omitempty\"`
     * @type {string}
     * @memberof MemberQueryRequest
     */
    Phone?: string;
    /**
     * å¼€å§‹æ—¶é—´. æŒ‡æ³¨å†Œ `binding:\"omitempty\"`
     * @type {number}
     * @memberof MemberQueryRequest
     */
    StartTime?: number;
}
/**
 * 
 * @export
 * @interface ModuleCreateRequest
 */
export interface ModuleCreateRequest {
    /**
     * åç§°
     * @type {string}
     * @memberof ModuleCreateRequest
     */
    Name?: string;
}
/**
 * 
 * @export
 * @interface ModuleDeleteRequest
 */
export interface ModuleDeleteRequest {
    /**
     * æ¨¡å—ID
     * @type {number}
     * @memberof ModuleDeleteRequest
     */
    ID?: number;
}
/**
 * 
 * @export
 * @interface ModuleTagsUpdateRequest
 */
export interface ModuleTagsUpdateRequest {
    /**
     * æ·»åŠ  `binding:\"omitempty\"`
     * @type {Array<number>}
     * @memberof ModuleTagsUpdateRequest
     */
    Add?: Array<number>;
    /**
     * åˆ é™¤ `binding:\"omitempty\"`
     * @type {Array<number>}
     * @memberof ModuleTagsUpdateRequest
     */
    Del?: Array<number>;
    /**
     * æ¨¡å—ID
     * @type {number}
     * @memberof ModuleTagsUpdateRequest
     */
    ID?: number;
}
/**
 * 
 * @export
 * @interface ModuleUpdateRequest
 */
export interface ModuleUpdateRequest {
    /**
     * æ¨¡å—ID
     * @type {number}
     * @memberof ModuleUpdateRequest
     */
    ID?: number;
    /**
     * åç§°
     * @type {string}
     * @memberof ModuleUpdateRequest
     */
    Name?: string;
}
/**
 * 
 * @export
 * @interface OrderCreateRequest
 */
export interface OrderCreateRequest {
    /**
     * å……å€¼é‡‘é¢. ä»…å½“ type æ˜¯å……å€¼ç±»å‹æ—¶æœ‰æ•ˆ `binding:\"omitempty\"`
     * @type {number}
     * @memberof OrderCreateRequest
     */
    Amount?: number;
    /**
     * å¥—é¤(ä¼šå‘˜)ç±»å‹. ä»…å½“ type æ˜¯ä¼šå‘˜ç±»å‹æ—¶æœ‰æ•ˆ `binding:\"omitempty\"`
     * @type {number}
     * @memberof OrderCreateRequest
     */
    MemberCardID?: number;
    /**
     * äº¤æ˜“ç±»å‹
     * @type {string}
     * @memberof OrderCreateRequest
     */
    Type?: OrderCreateRequestTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OrderCreateRequestTypeEnum {
    ä¼šå‘˜ = 'ä¼šå‘˜',
    å……å€¼ = 'å……å€¼'
}

/**
 * 
 * @export
 * @interface OrderDeleteRequest
 */
export interface OrderDeleteRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof OrderDeleteRequest
     */
    Ids?: Array<number>;
}
/**
 * 
 * @export
 * @interface OrderListRequest
 */
export interface OrderListRequest {
    /**
     * ç»“æŸæ—¶é—´ `binding:\"omitempty\"`
     * @type {number}
     * @memberof OrderListRequest
     */
    EndTime?: number;
    /**
     * å¼€å§‹æ—¶é—´ `binding:\"omitempty\"`
     * @type {number}
     * @memberof OrderListRequest
     */
    StartTime?: number;
    /**
     * äº¤æ˜“çŠ¶æ€ `binding:\"omitempty\"`
     * @type {string}
     * @memberof OrderListRequest
     */
    Status?: OrderListRequestStatusEnum;
    /**
     * äº¤æ˜“ç±»å‹ `binding:\"omitempty\"`
     * @type {string}
     * @memberof OrderListRequest
     */
    Type?: OrderListRequestTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OrderListRequestStatusEnum {
    å¾…æ”¯ä»˜ = 'å¾…æ”¯ä»˜',
    äº¤æ˜“æˆåŠŸ = 'äº¤æ˜“æˆåŠŸ',
    äº¤æ˜“å¤±è´¥ = 'äº¤æ˜“å¤±è´¥'
}
/**
    * @export
    * @enum {string}
    */
export enum OrderListRequestTypeEnum {
    ä¼šå‘˜ = 'ä¼šå‘˜',
    å……å€¼ = 'å……å€¼'
}

/**
 * 
 * @export
 * @interface OrderQueryRequest
 */
export interface OrderQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderQueryRequest
     */
    TradeNo?: string;
}
/**
 * 
 * @export
 * @interface OrderUpdateRequest
 */
export interface OrderUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof OrderUpdateRequest
     */
    ID?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdateRequest
     */
    Remark?: string;
}
/**
 * 
 * @export
 * @interface ProjectQueryRequest
 */
export interface ProjectQueryRequest {
    /**
     * æ–¹æ¡ˆåˆ›å»ºæ—¶é—´, åŒºé—´çš„ç»“æŸ
     * @type {number}
     * @memberof ProjectQueryRequest
     */
    CreatedAtE?: number;
    /**
     * æ–¹æ¡ˆåˆ›å»ºæ—¶é—´, åŒºé—´çš„å¼€å§‹
     * @type {number}
     * @memberof ProjectQueryRequest
     */
    CreatedAtS?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectQueryRequest
     */
    Limit?: number;
    /**
     * æ–¹æ¡ˆåç§°
     * @type {string}
     * @memberof ProjectQueryRequest
     */
    Name?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectQueryRequest
     */
    Offset?: number;
    /**
     * ç”¨æˆ·ç”µè¯. æ¨¡ç³ŠæŸ¥è¯¢, ä»…å·¥å‚ç«¯å¯ç”¨
     * @type {string}
     * @memberof ProjectQueryRequest
     */
    Phone?: string;
}
/**
 * 
 * @export
 * @interface QuoteMaterialCreateRequest
 */
export interface QuoteMaterialCreateRequest {
    /**
     * æè´¨
     * @type {string}
     * @memberof QuoteMaterialCreateRequest
     */
    Material?: string;
    /**
     * å‹å·
     * @type {string}
     * @memberof QuoteMaterialCreateRequest
     */
    Model?: string;
    /**
     * è§„æ ¼
     * @type {string}
     * @memberof QuoteMaterialCreateRequest
     */
    Spec?: string;
    /**
     * å•ä»·
     * @type {number}
     * @memberof QuoteMaterialCreateRequest
     */
    UnitPrice?: number;
}
/**
 * 
 * @export
 * @interface QuoteMaterialDeleteRequest
 */
export interface QuoteMaterialDeleteRequest {
    /**
     * 
     * @type {Array<QuoteMaterialDeleteRequestItems>}
     * @memberof QuoteMaterialDeleteRequest
     */
    Items?: Array<QuoteMaterialDeleteRequestItems>;
}
/**
 * 
 * @export
 * @interface QuoteMaterialDeleteRequestItems
 */
export interface QuoteMaterialDeleteRequestItems {
    /**
     * 
     * @type {string}
     * @memberof QuoteMaterialDeleteRequestItems
     */
    Material?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteMaterialDeleteRequestItems
     */
    Model?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteMaterialDeleteRequestItems
     */
    Spec?: string;
}
/**
 * 
 * @export
 * @interface QuoteMaterialUpdateRequest
 */
export interface QuoteMaterialUpdateRequest {
    /**
     * æè´¨
     * @type {string}
     * @memberof QuoteMaterialUpdateRequest
     */
    Material?: string;
    /**
     * å‹å·
     * @type {string}
     * @memberof QuoteMaterialUpdateRequest
     */
    Model?: string;
    /**
     * æ–°çš„æè´¨
     * @type {string}
     * @memberof QuoteMaterialUpdateRequest
     */
    NewMaterial?: string;
    /**
     * æ–°çš„å•ä»·
     * @type {number}
     * @memberof QuoteMaterialUpdateRequest
     */
    NewUnitPrice?: number;
    /**
     * è§„æ ¼
     * @type {string}
     * @memberof QuoteMaterialUpdateRequest
     */
    Spec?: string;
}
/**
 * 
 * @export
 * @interface QuoteModelCreateRequest
 */
export interface QuoteModelCreateRequest {
    /**
     * å‹å·
     * @type {string}
     * @memberof QuoteModelCreateRequest
     */
    Model?: string;
    /**
     * è®¡ä»·ç±»å‹
     * @type {string}
     * @memberof QuoteModelCreateRequest
     */
    Type?: QuoteModelCreateRequestTypeEnum;
    /**
     * è®¡ä»·å•ä½
     * @type {string}
     * @memberof QuoteModelCreateRequest
     */
    Unit?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum QuoteModelCreateRequestTypeEnum {
    å°æŸ± = 'å°æŸ±',
    å¼¯å­ = 'å¼¯å­',
    é¡¶æ–¹ = 'é¡¶æ–¹',
    è¸æ¿ = 'è¸æ¿',
    æ•´ä½“ = 'æ•´ä½“',
    é…ä»¶ = 'é…ä»¶'
}

/**
 * 
 * @export
 * @interface QuoteModelDeleteRequest
 */
export interface QuoteModelDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof QuoteModelDeleteRequest
     */
    Models?: Array<string>;
}
/**
 * 
 * @export
 * @interface QuoteModelUpdateRequest
 */
export interface QuoteModelUpdateRequest {
    /**
     * å‹å·
     * @type {string}
     * @memberof QuoteModelUpdateRequest
     */
    Model?: string;
    /**
     * æ–°çš„å‹å·
     * @type {string}
     * @memberof QuoteModelUpdateRequest
     */
    NewModel?: string;
    /**
     * è®¡ä»·ç±»å‹
     * @type {string}
     * @memberof QuoteModelUpdateRequest
     */
    Type?: QuoteModelUpdateRequestTypeEnum;
    /**
     * è®¡ä»·å•ä½
     * @type {string}
     * @memberof QuoteModelUpdateRequest
     */
    Unit?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum QuoteModelUpdateRequestTypeEnum {
    å°æŸ± = 'å°æŸ±',
    å¼¯å­ = 'å¼¯å­',
    é¡¶æ–¹ = 'é¡¶æ–¹',
    è¸æ¿ = 'è¸æ¿',
    æ•´ä½“ = 'æ•´ä½“',
    é…ä»¶ = 'é…ä»¶'
}

/**
 * 
 * @export
 * @interface QuoteQueryRequest
 */
export interface QuoteQueryRequest {
    /**
     * äº§å“å‹å· `binding:\"omitempty\"`
     * @type {string}
     * @memberof QuoteQueryRequest
     */
    Model?: string;
    /**
     * äº§å“è§„æ ¼ `binding:\"omitempty\"`
     * @type {string}
     * @memberof QuoteQueryRequest
     */
    Spec?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQueryRequest
     */
    Type?: QuoteQueryRequestTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum QuoteQueryRequestTypeEnum {
    å°æŸ± = 'å°æŸ±',
    å¼¯å­ = 'å¼¯å­',
    é¡¶æ–¹ = 'é¡¶æ–¹',
    è¸æ¿ = 'è¸æ¿',
    æ•´ä½“ = 'æ•´ä½“',
    é…ä»¶ = 'é…ä»¶'
}

/**
 * 
 * @export
 * @interface QuoteSpecCreateRequest
 */
export interface QuoteSpecCreateRequest {
    /**
     * å‹å·
     * @type {string}
     * @memberof QuoteSpecCreateRequest
     */
    Model?: string;
    /**
     * è§„æ ¼
     * @type {string}
     * @memberof QuoteSpecCreateRequest
     */
    Spec?: string;
}
/**
 * 
 * @export
 * @interface QuoteSpecDeleteRequest
 */
export interface QuoteSpecDeleteRequest {
    /**
     * 
     * @type {Array<QuoteSpecDeleteRequestItems>}
     * @memberof QuoteSpecDeleteRequest
     */
    Items?: Array<QuoteSpecDeleteRequestItems>;
}
/**
 * 
 * @export
 * @interface QuoteSpecDeleteRequestItems
 */
export interface QuoteSpecDeleteRequestItems {
    /**
     * 
     * @type {string}
     * @memberof QuoteSpecDeleteRequestItems
     */
    Model?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteSpecDeleteRequestItems
     */
    Spec?: string;
}
/**
 * 
 * @export
 * @interface QuoteSpecUpdateRequest
 */
export interface QuoteSpecUpdateRequest {
    /**
     * å‹å·
     * @type {string}
     * @memberof QuoteSpecUpdateRequest
     */
    Model?: string;
    /**
     * æ–°è§„æ ¼
     * @type {string}
     * @memberof QuoteSpecUpdateRequest
     */
    NewSpec?: string;
    /**
     * æ—§è§„æ ¼
     * @type {string}
     * @memberof QuoteSpecUpdateRequest
     */
    Spec?: string;
}
/**
 * 
 * @export
 * @interface StairCreateRequest
 */
export interface StairCreateRequest {
    /**
     * åç§°
     * @type {string}
     * @memberof StairCreateRequest
     */
    Name?: string;
    /**
     * æ¥¼æ¢¯åºåˆ—åŒ–åçš„å­—ç¬¦ä¸²
     * @type {string}
     * @memberof StairCreateRequest
     */
    Payload?: string;
    /**
     * é¢„è§ˆå›¾
     * @type {string}
     * @memberof StairCreateRequest
     */
    Preview?: string;
    /**
     * æ ‡ç­¾
     * @type {object}
     * @memberof StairCreateRequest
     */
    Tags?: object;
}
/**
 * 
 * @export
 * @interface StairDeleteRequest
 */
export interface StairDeleteRequest {
    /**
     * `binding:\"min=1\"`
     * @type {Array<number>}
     * @memberof StairDeleteRequest
     */
    Ids?: Array<number>;
}
/**
 * 
 * @export
 * @interface StairDetailRequest
 */
export interface StairDetailRequest {
    /**
     * æ¥¼æ¢¯ID
     * @type {number}
     * @memberof StairDetailRequest
     */
    ID?: number;
}
/**
 * 
 * @export
 * @interface StairQueryRequest
 */
export interface StairQueryRequest {
    /**
     * åç§°. æ¨¡ç³ŠæŸ¥è¯¢ `binding:\"omitempty\"`
     * @type {string}
     * @memberof StairQueryRequest
     */
    Name?: string;
    /**
     * æ‰€æœ‰è€… `binding:\"omitempty\"`
     * @type {number}
     * @memberof StairQueryRequest
     */
    Owner?: number;
    /**
     * æ ‡ç­¾. `binding:\"omitempty\"`
     * @type {object}
     * @memberof StairQueryRequest
     */
    Tags?: object;
}
/**
 * 
 * @export
 * @interface StairUpdateRequest
 */
export interface StairUpdateRequest {
    /**
     * æ¥¼æ¢¯ID
     * @type {number}
     * @memberof StairUpdateRequest
     */
    ID?: number;
    /**
     * åç§°
     * @type {string}
     * @memberof StairUpdateRequest
     */
    Name?: string;
    /**
     * æ¥¼æ¢¯åºåˆ—åŒ–åçš„å­—ç¬¦ä¸²
     * @type {string}
     * @memberof StairUpdateRequest
     */
    Payload?: string;
    /**
     * é¢„è§ˆå›¾
     * @type {string}
     * @memberof StairUpdateRequest
     */
    Preview?: string;
    /**
     * æ ‡ç­¾
     * @type {object}
     * @memberof StairUpdateRequest
     */
    Tags?: object;
}
/**
 * 
 * @export
 * @interface TagCreateRequest
 */
export interface TagCreateRequest {
    /**
     * åç§°
     * @type {string}
     * @memberof TagCreateRequest
     */
    Name?: string;
}
/**
 * 
 * @export
 * @interface TagDeleteRequest
 */
export interface TagDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof TagDeleteRequest
     */
    ID?: number;
}
/**
 * 
 * @export
 * @interface TagItemCreateRequest
 */
export interface TagItemCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TagItemCreateRequest
     */
    Name?: string;
    /**
     * 
     * @type {number}
     * @memberof TagItemCreateRequest
     */
    TagID?: number;
}
/**
 * 
 * @export
 * @interface TagItemDeleteRequest
 */
export interface TagItemDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof TagItemDeleteRequest
     */
    ID?: number;
}
/**
 * 
 * @export
 * @interface TagItemDragSortRequest
 */
export interface TagItemDragSortRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof TagItemDragSortRequest
     */
    Sorted?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof TagItemDragSortRequest
     */
    TagID?: number;
}
/**
 * 
 * @export
 * @interface TagItemUpdateRequest
 */
export interface TagItemUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof TagItemUpdateRequest
     */
    ID?: number;
    /**
     * 
     * @type {string}
     * @memberof TagItemUpdateRequest
     */
    Name?: string;
}
/**
 * 
 * @export
 * @interface TagUpdateRequest
 */
export interface TagUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof TagUpdateRequest
     */
    ID?: number;
    /**
     * 
     * @type {string}
     * @memberof TagUpdateRequest
     */
    Name?: string;
}
/**
 * 
 * @export
 * @interface UserRegisterRequest
 */
export interface UserRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRegisterRequest
     */
    Captcha?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegisterRequest
     */
    Password?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegisterRequest
     */
    Phone?: string;
}
/**
 * 
 * @export
 * @interface UserResetPasswordRequest
 */
export interface UserResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof UserResetPasswordRequest
     */
    Captcha?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResetPasswordRequest
     */
    Password?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResetPasswordRequest
     */
    Phone?: string;
}
/**
 * 
 * @export
 * @interface UserSendCaptchaRequest
 */
export interface UserSendCaptchaRequest {
    /**
     * 
     * @type {string}
     * @memberof UserSendCaptchaRequest
     */
    Phone?: string;
}
/**
 * 
 * @export
 * @interface UserUpdateProfileRequest
 */
export interface UserUpdateProfileRequest {
    /**
     * 
     * @type {Address}
     * @memberof UserUpdateProfileRequest
     */
    Address?: Address;
    /**
     * å¤´åƒ `binding:\"omitempty\"`
     * @type {string}
     * @memberof UserUpdateProfileRequest
     */
    Avatar?: string;
    /**
     * æ˜µç§° `binding:\"omitempty\"`
     * @type {string}
     * @memberof UserUpdateProfileRequest
     */
    NickName?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * æ‰¹é‡æ·»åŠ æˆªé¢
         * @summary æ‰¹é‡æ·»åŠ æˆªé¢
         * @param {D2ModelCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d2ModelCreate: async (body?: D2ModelCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/d2_model/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ é™¤æˆªé¢
         * @summary åˆ é™¤æˆªé¢
         * @param {D2ModelDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d2ModelDelete: async (body?: D2ModelDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/d2_model/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æŸ¥è¯¢æˆªé¢
         * @summary æŸ¥è¯¢æˆªé¢
         * @param {D2ModelQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d2ModelQuery: async (body?: D2ModelQueryRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/d2_model/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ›´æ–°æˆªé¢
         * @summary æ›´æ–°æˆªé¢
         * @param {D2ModelUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d2ModelUpdate: async (body?: D2ModelUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/d2_model/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ‰¹é‡æ·»åŠ 3Dæ¨¡å‹
         * @summary æ‰¹é‡æ·»åŠ 3Dæ¨¡å‹
         * @param {D3ModelCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d3ModelCreate: async (body?: D3ModelCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/d3_model/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ é™¤3Dæ¨¡å‹
         * @summary åˆ é™¤3Dæ¨¡å‹
         * @param {D3ModelDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d3ModelDelete: async (body?: D3ModelDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/d3_model/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æŸ¥è¯¢3Dæ¨¡å‹
         * @summary æŸ¥è¯¢3Dæ¨¡å‹
         * @param {D3ModelQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d3ModelQuery: async (body?: D3ModelQueryRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/d3_model/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ›´æ–°3Dæ¨¡å‹
         * @summary æ›´æ–°3Dæ¨¡å‹
         * @param {D3ModelUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d3ModelUpdate: async (body?: D3ModelUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/d3_model/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ‰¹é‡æ·»åŠ æè´¨
         * @summary æ‰¹é‡æ·»åŠ æè´¨
         * @param {MaterialCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        materialCreate: async (body?: MaterialCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/material/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ é™¤æè´¨
         * @summary åˆ é™¤æè´¨
         * @param {MaterialDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        materialDelete: async (body?: MaterialDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/material/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ ¹æ®åç§°åˆ—è¡¨æŸ¥è¯¢æè´¨
         * @summary æ ¹æ®åç§°åˆ—è¡¨æŸ¥è¯¢æè´¨
         * @param {MaterialListByNameRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        materialListByName: async (body?: MaterialListByNameRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/material/list_by_name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æŸ¥è¯¢æè´¨
         * @summary æŸ¥è¯¢æè´¨
         * @param {MaterialQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        materialQuery: async (body?: MaterialQueryRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/material/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ›´æ–°æè´¨
         * @summary æ›´æ–°æè´¨
         * @param {MaterialUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        materialUpdate: async (body?: MaterialUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/material/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ–°å»ºä¼šå‘˜å¡
         * @summary æ–°å»ºä¼šå‘˜å¡
         * @param {MemberCardCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberCardCreate: async (body?: MemberCardCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/member_card/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ é™¤ä¼šå‘˜å¡
         * @summary åˆ é™¤ä¼šå‘˜å¡
         * @param {MemberCardDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberCardDelete: async (body?: MemberCardDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/member_card/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æŸ¥è¯¢ä¼šå‘˜å¡ä¿¡æ¯
         * @summary æŸ¥è¯¢ä¼šå‘˜å¡ä¿¡æ¯
         * @param {MemberCardQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberCardQuery: async (body?: MemberCardQueryRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/member_card/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ›´æ–°ä¼šå‘˜å¡
         * @summary æ›´æ–°ä¼šå‘˜å¡
         * @param {MemberCardUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberCardUpdate: async (body?: MemberCardUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/member_card/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ›´æ–°ä¼šå‘˜å¡é”€å”®çŠ¶æ€
         * @summary æ›´æ–°ä¼šå‘˜å¡é”€å”®çŠ¶æ€
         * @param {MemberCardUpdateSalesStatusRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberCardUpdateSalesStatus: async (body?: MemberCardUpdateSalesStatusRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/member_card/update_sales_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ä¼šå‘˜æŸ¥è¯¢
         * @summary ä¼šå‘˜æŸ¥è¯¢
         * @param {MemberQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberQuery: async (body?: MemberQueryRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/member/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ–°å»ºæ¨¡å—
         * @summary æ–°å»ºæ¨¡å—
         * @param {ModuleCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreate: async (body?: ModuleCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/module/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ é™¤æ¨¡å—
         * @summary åˆ é™¤æ¨¡å—
         * @param {ModuleDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleDelete: async (body?: ModuleDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/module/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æŸ¥è¯¢æ¨¡å—
         * @summary æŸ¥è¯¢æ¨¡å—
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleQuery: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/module/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ›´æ–°æ¨¡å—çš„æ ‡ç­¾
         * @summary æ›´æ–°æ¨¡å—çš„æ ‡ç­¾
         * @param {ModuleTagsUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleTagsUpdate: async (body?: ModuleTagsUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/module/tags/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ›´æ–°æ¨¡å—
         * @summary æ›´æ–°æ¨¡å—
         * @param {ModuleUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpdate: async (body?: ModuleUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/module/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ–°å»ºè®¢å•
         * @summary æ–°å»ºè®¢å•
         * @param {OrderCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCreate: async (body?: OrderCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ é™¤è®¢å•
         * @summary åˆ é™¤è®¢å•
         * @param {OrderDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDelete: async (body?: OrderDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * è®¢å•åˆ—è¡¨
         * @summary è®¢å•åˆ—è¡¨
         * @param {OrderListRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderList: async (body?: OrderListRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æŸ¥è¯¢å•ä¸ªè®¢å•. `ç”¨äºæ”¯ä»˜åæŸ¥è¯¢è®¢å•çŠ¶æ€`
         * @summary æŸ¥è¯¢å•ä¸ªè®¢å•. `ç”¨äºæ”¯ä»˜åæŸ¥è¯¢è®¢å•çŠ¶æ€`
         * @param {OrderQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderQuery: async (body?: OrderQueryRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ›´æ–°è®¢å•, `å½“å‰ä»…æ”¯æŒç®¡ç†å‘˜æ·»åŠ å¤‡æ³¨`
         * @summary æ›´æ–°è®¢å•, `å½“å‰ä»…æ”¯æŒç®¡ç†å‘˜æ·»åŠ å¤‡æ³¨`
         * @param {OrderUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderUpdate: async (body?: OrderUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ–¹æ¡ˆæŸ¥è¯¢
         * @summary æ–¹æ¡ˆæŸ¥è¯¢
         * @param {ProjectQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectQuery: async (body?: ProjectQueryRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/project/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ–°å¢äº§å“æè´¨æŠ¥ä»·
         * @summary æ–°å¢äº§å“æè´¨æŠ¥ä»·
         * @param {QuoteMaterialCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteMaterialCreate: async (body?: QuoteMaterialCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quote/material_create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ é™¤äº§å“æè´¨æŠ¥ä»·
         * @summary åˆ é™¤äº§å“æè´¨æŠ¥ä»·
         * @param {QuoteMaterialDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteMaterialDelete: async (body?: QuoteMaterialDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quote/material_delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ä¿®æ”¹äº§å“æè´¨æŠ¥ä»·
         * @summary ä¿®æ”¹äº§å“æè´¨æŠ¥ä»·
         * @param {QuoteMaterialUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteMaterialUpdate: async (body?: QuoteMaterialUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quote/material_update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ–°å¢äº§å“å‹å·
         * @summary æ–°å¢äº§å“å‹å·
         * @param {QuoteModelCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteModelCreate: async (body?: QuoteModelCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quote/model_create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ é™¤äº§å“å‹å·
         * @summary åˆ é™¤äº§å“å‹å·
         * @param {QuoteModelDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteModelDelete: async (body?: QuoteModelDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quote/model_delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ä¿®æ”¹äº§å“å‹å·
         * @summary ä¿®æ”¹äº§å“å‹å·
         * @param {QuoteModelUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteModelUpdate: async (body?: QuoteModelUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quote/model_update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æŠ¥ä»·æŸ¥è¯¢
         * @summary æŠ¥ä»·æŸ¥è¯¢
         * @param {QuoteQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteQuery: async (body?: QuoteQueryRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quote/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ–°å¢äº§å“è§„æ ¼
         * @summary æ–°å¢äº§å“è§„æ ¼
         * @param {QuoteSpecCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteSpecCreate: async (body?: QuoteSpecCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quote/spec_create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ é™¤äº§å“è§„æ ¼
         * @summary åˆ é™¤äº§å“è§„æ ¼
         * @param {QuoteSpecDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteSpecDelete: async (body?: QuoteSpecDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quote/spec_delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ä¿®æ”¹äº§å“è§„æ ¼
         * @summary ä¿®æ”¹äº§å“è§„æ ¼
         * @param {QuoteSpecUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteSpecUpdate: async (body?: QuoteSpecUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quote/spec_update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ–°å»ºæ¥¼æ¢¯
         * @summary æ–°å»ºæ¥¼æ¢¯
         * @param {StairCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stairCreate: async (body?: StairCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stair/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ é™¤æ¥¼æ¢¯
         * @summary åˆ é™¤æ¥¼æ¢¯
         * @param {StairDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stairDelete: async (body?: StairDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stair/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ¥¼æ¢¯è¯¦æƒ…
         * @summary æ¥¼æ¢¯è¯¦æƒ…
         * @param {StairDetailRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stairDetail: async (body?: StairDetailRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stair/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æŸ¥è¯¢æ¥¼æ¢¯
         * @summary æŸ¥è¯¢æ¥¼æ¢¯
         * @param {StairQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stairQuery: async (body?: StairQueryRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stair/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ›´æ–°æ¥¼æ¢¯
         * @summary æ›´æ–°æ¥¼æ¢¯
         * @param {StairUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stairUpdate: async (body?: StairUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stair/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ–°å»ºæ ‡ç­¾
         * @summary æ–°å»ºæ ‡ç­¾
         * @param {TagCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagCreate: async (body?: TagCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tag/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ é™¤æ ‡ç­¾
         * @summary åˆ é™¤æ ‡ç­¾
         * @param {TagDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDelete: async (body?: TagDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tag/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ ‡ç­¾é¡¹-æ·»åŠ 
         * @summary æ ‡ç­¾é¡¹-æ·»åŠ 
         * @param {TagItemCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagItemCreate: async (body?: TagItemCreateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tag/item/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ ‡ç­¾é¡¹-åˆ é™¤
         * @summary æ ‡ç­¾é¡¹-åˆ é™¤
         * @param {TagItemDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagItemDelete: async (body?: TagItemDeleteRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tag/item/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ! `ä½¿ç”¨äº† PostgreSQL ä¸“æœ‰çš„è¯­æ³•, ä¸æ”¯æŒæµ‹è¯•ç¯å¢ƒ` tag_id: æ ‡ç­¾ID sorted: æ’å¥½åºçš„æ ‡ç­¾é¡¹IDæ•°ç»„, å¦‚ [1326156906414215168, 1326179034668732416, 1326178972534312960]
         * @summary æ ‡ç­¾é¡¹-æ‹–æ‹½æ’åº
         * @param {TagItemDragSortRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagItemDragSort: async (body?: TagItemDragSortRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tag/item/drag_sort`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ ‡ç­¾é¡¹-ç¼–è¾‘
         * @summary æ ‡ç­¾é¡¹-ç¼–è¾‘
         * @param {TagItemUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagItemUpdate: async (body?: TagItemUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tag/item/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æŸ¥è¯¢æ ‡ç­¾
         * @summary æŸ¥è¯¢æ ‡ç­¾
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagQuery: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tag/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ›´æ–°æ ‡ç­¾
         * @summary æ›´æ–°æ ‡ç­¾
         * @param {TagUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate: async (body?: TagUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tag/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * è·³è½¬åˆ°è®¾è®¡å·¥å…·è‡ªåŠ¨ç™»å½•éœ€è¦çš„ä¿¡æ¯
         * @summary è·³è½¬åˆ°è®¾è®¡å·¥å…·è‡ªåŠ¨ç™»å½•éœ€è¦çš„ä¿¡æ¯
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDesignToken: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/design_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ç™»å½•
         * @summary ç™»å½•
         * @param {Login} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin: async (body?: Login, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * é€€å‡ºç™»å½•
         * @summary é€€å‡ºç™»å½•
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogout: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * åˆ·æ–°Token
         * @summary åˆ·æ–°Token
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRefreshToken: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/refresh_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ³¨å†Œ
         * @summary æ³¨å†Œ
         * @param {UserRegisterRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegister: async (body?: UserRegisterRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * é‡ç½®å¯†ç 
         * @summary é‡ç½®å¯†ç 
         * @param {UserResetPasswordRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userResetPassword: async (body?: UserResetPasswordRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/reset_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * å‘é€éªŒè¯ç 
         * @summary å‘é€éªŒè¯ç 
         * @param {UserSendCaptchaRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSendCaptcha: async (body?: UserSendCaptchaRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/send_sms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * æ›´æ–°ç”¨æˆ·ä¿¡æ¯
         * @summary æ›´æ–°ç”¨æˆ·ä¿¡æ¯
         * @param {UserUpdateProfileRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateProfile: async (body?: UserUpdateProfileRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/update_profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ç»é”€å•†çš„ä¸Šä¼ è·¯å¾„ä¸º `/user/${uid}/_*` ç®¡ç†å‘˜çš„ä¸Šä¼ è·¯å¾„ä¸º `/static/_*` å’Œ `/user/${uid}/_*`
         * @summary è·å–ç”¨äºå‰ç«¯ç›´ä¼ è·å–æœåŠ¡ç«¯ç­¾åæˆ–ä¸´æ—¶å¯†é’¥
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUploadCredential: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/upload_credential`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * æ‰¹é‡æ·»åŠ æˆªé¢
         * @summary æ‰¹é‡æ·»åŠ æˆªé¢
         * @param {D2ModelCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async d2ModelCreate(body?: D2ModelCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.d2ModelCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ é™¤æˆªé¢
         * @summary åˆ é™¤æˆªé¢
         * @param {D2ModelDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async d2ModelDelete(body?: D2ModelDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.d2ModelDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æŸ¥è¯¢æˆªé¢
         * @summary æŸ¥è¯¢æˆªé¢
         * @param {D2ModelQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async d2ModelQuery(body?: D2ModelQueryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.d2ModelQuery(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ›´æ–°æˆªé¢
         * @summary æ›´æ–°æˆªé¢
         * @param {D2ModelUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async d2ModelUpdate(body?: D2ModelUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.d2ModelUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ‰¹é‡æ·»åŠ 3Dæ¨¡å‹
         * @summary æ‰¹é‡æ·»åŠ 3Dæ¨¡å‹
         * @param {D3ModelCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async d3ModelCreate(body?: D3ModelCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.d3ModelCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ é™¤3Dæ¨¡å‹
         * @summary åˆ é™¤3Dæ¨¡å‹
         * @param {D3ModelDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async d3ModelDelete(body?: D3ModelDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.d3ModelDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æŸ¥è¯¢3Dæ¨¡å‹
         * @summary æŸ¥è¯¢3Dæ¨¡å‹
         * @param {D3ModelQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async d3ModelQuery(body?: D3ModelQueryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.d3ModelQuery(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ›´æ–°3Dæ¨¡å‹
         * @summary æ›´æ–°3Dæ¨¡å‹
         * @param {D3ModelUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async d3ModelUpdate(body?: D3ModelUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.d3ModelUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ‰¹é‡æ·»åŠ æè´¨
         * @summary æ‰¹é‡æ·»åŠ æè´¨
         * @param {MaterialCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async materialCreate(body?: MaterialCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.materialCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ é™¤æè´¨
         * @summary åˆ é™¤æè´¨
         * @param {MaterialDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async materialDelete(body?: MaterialDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.materialDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ ¹æ®åç§°åˆ—è¡¨æŸ¥è¯¢æè´¨
         * @summary æ ¹æ®åç§°åˆ—è¡¨æŸ¥è¯¢æè´¨
         * @param {MaterialListByNameRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async materialListByName(body?: MaterialListByNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.materialListByName(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æŸ¥è¯¢æè´¨
         * @summary æŸ¥è¯¢æè´¨
         * @param {MaterialQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async materialQuery(body?: MaterialQueryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.materialQuery(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ›´æ–°æè´¨
         * @summary æ›´æ–°æè´¨
         * @param {MaterialUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async materialUpdate(body?: MaterialUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.materialUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ–°å»ºä¼šå‘˜å¡
         * @summary æ–°å»ºä¼šå‘˜å¡
         * @param {MemberCardCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async memberCardCreate(body?: MemberCardCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.memberCardCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ é™¤ä¼šå‘˜å¡
         * @summary åˆ é™¤ä¼šå‘˜å¡
         * @param {MemberCardDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async memberCardDelete(body?: MemberCardDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.memberCardDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æŸ¥è¯¢ä¼šå‘˜å¡ä¿¡æ¯
         * @summary æŸ¥è¯¢ä¼šå‘˜å¡ä¿¡æ¯
         * @param {MemberCardQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async memberCardQuery(body?: MemberCardQueryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.memberCardQuery(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ›´æ–°ä¼šå‘˜å¡
         * @summary æ›´æ–°ä¼šå‘˜å¡
         * @param {MemberCardUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async memberCardUpdate(body?: MemberCardUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.memberCardUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ›´æ–°ä¼šå‘˜å¡é”€å”®çŠ¶æ€
         * @summary æ›´æ–°ä¼šå‘˜å¡é”€å”®çŠ¶æ€
         * @param {MemberCardUpdateSalesStatusRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async memberCardUpdateSalesStatus(body?: MemberCardUpdateSalesStatusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.memberCardUpdateSalesStatus(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ä¼šå‘˜æŸ¥è¯¢
         * @summary ä¼šå‘˜æŸ¥è¯¢
         * @param {MemberQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async memberQuery(body?: MemberQueryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.memberQuery(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ–°å»ºæ¨¡å—
         * @summary æ–°å»ºæ¨¡å—
         * @param {ModuleCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleCreate(body?: ModuleCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ é™¤æ¨¡å—
         * @summary åˆ é™¤æ¨¡å—
         * @param {ModuleDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleDelete(body?: ModuleDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æŸ¥è¯¢æ¨¡å—
         * @summary æŸ¥è¯¢æ¨¡å—
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleQuery(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleQuery(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ›´æ–°æ¨¡å—çš„æ ‡ç­¾
         * @summary æ›´æ–°æ¨¡å—çš„æ ‡ç­¾
         * @param {ModuleTagsUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleTagsUpdate(body?: ModuleTagsUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleTagsUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ›´æ–°æ¨¡å—
         * @summary æ›´æ–°æ¨¡å—
         * @param {ModuleUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleUpdate(body?: ModuleUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ–°å»ºè®¢å•
         * @summary æ–°å»ºè®¢å•
         * @param {OrderCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderCreate(body?: OrderCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ é™¤è®¢å•
         * @summary åˆ é™¤è®¢å•
         * @param {OrderDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDelete(body?: OrderDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * è®¢å•åˆ—è¡¨
         * @summary è®¢å•åˆ—è¡¨
         * @param {OrderListRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderList(body?: OrderListRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderList(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æŸ¥è¯¢å•ä¸ªè®¢å•. `ç”¨äºæ”¯ä»˜åæŸ¥è¯¢è®¢å•çŠ¶æ€`
         * @summary æŸ¥è¯¢å•ä¸ªè®¢å•. `ç”¨äºæ”¯ä»˜åæŸ¥è¯¢è®¢å•çŠ¶æ€`
         * @param {OrderQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderQuery(body?: OrderQueryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderQuery(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ›´æ–°è®¢å•, `å½“å‰ä»…æ”¯æŒç®¡ç†å‘˜æ·»åŠ å¤‡æ³¨`
         * @summary æ›´æ–°è®¢å•, `å½“å‰ä»…æ”¯æŒç®¡ç†å‘˜æ·»åŠ å¤‡æ³¨`
         * @param {OrderUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderUpdate(body?: OrderUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ–¹æ¡ˆæŸ¥è¯¢
         * @summary æ–¹æ¡ˆæŸ¥è¯¢
         * @param {ProjectQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectQuery(body?: ProjectQueryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectQuery(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ–°å¢äº§å“æè´¨æŠ¥ä»·
         * @summary æ–°å¢äº§å“æè´¨æŠ¥ä»·
         * @param {QuoteMaterialCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteMaterialCreate(body?: QuoteMaterialCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteMaterialCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ é™¤äº§å“æè´¨æŠ¥ä»·
         * @summary åˆ é™¤äº§å“æè´¨æŠ¥ä»·
         * @param {QuoteMaterialDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteMaterialDelete(body?: QuoteMaterialDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteMaterialDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ä¿®æ”¹äº§å“æè´¨æŠ¥ä»·
         * @summary ä¿®æ”¹äº§å“æè´¨æŠ¥ä»·
         * @param {QuoteMaterialUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteMaterialUpdate(body?: QuoteMaterialUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteMaterialUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ–°å¢äº§å“å‹å·
         * @summary æ–°å¢äº§å“å‹å·
         * @param {QuoteModelCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteModelCreate(body?: QuoteModelCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteModelCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ é™¤äº§å“å‹å·
         * @summary åˆ é™¤äº§å“å‹å·
         * @param {QuoteModelDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteModelDelete(body?: QuoteModelDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteModelDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ä¿®æ”¹äº§å“å‹å·
         * @summary ä¿®æ”¹äº§å“å‹å·
         * @param {QuoteModelUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteModelUpdate(body?: QuoteModelUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteModelUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æŠ¥ä»·æŸ¥è¯¢
         * @summary æŠ¥ä»·æŸ¥è¯¢
         * @param {QuoteQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteQuery(body?: QuoteQueryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteQuery(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ–°å¢äº§å“è§„æ ¼
         * @summary æ–°å¢äº§å“è§„æ ¼
         * @param {QuoteSpecCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteSpecCreate(body?: QuoteSpecCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteSpecCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ é™¤äº§å“è§„æ ¼
         * @summary åˆ é™¤äº§å“è§„æ ¼
         * @param {QuoteSpecDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteSpecDelete(body?: QuoteSpecDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteSpecDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ä¿®æ”¹äº§å“è§„æ ¼
         * @summary ä¿®æ”¹äº§å“è§„æ ¼
         * @param {QuoteSpecUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteSpecUpdate(body?: QuoteSpecUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteSpecUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ–°å»ºæ¥¼æ¢¯
         * @summary æ–°å»ºæ¥¼æ¢¯
         * @param {StairCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stairCreate(body?: StairCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stairCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ é™¤æ¥¼æ¢¯
         * @summary åˆ é™¤æ¥¼æ¢¯
         * @param {StairDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stairDelete(body?: StairDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stairDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ¥¼æ¢¯è¯¦æƒ…
         * @summary æ¥¼æ¢¯è¯¦æƒ…
         * @param {StairDetailRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stairDetail(body?: StairDetailRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stairDetail(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æŸ¥è¯¢æ¥¼æ¢¯
         * @summary æŸ¥è¯¢æ¥¼æ¢¯
         * @param {StairQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stairQuery(body?: StairQueryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stairQuery(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ›´æ–°æ¥¼æ¢¯
         * @summary æ›´æ–°æ¥¼æ¢¯
         * @param {StairUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stairUpdate(body?: StairUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stairUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ–°å»ºæ ‡ç­¾
         * @summary æ–°å»ºæ ‡ç­¾
         * @param {TagCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagCreate(body?: TagCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ é™¤æ ‡ç­¾
         * @summary åˆ é™¤æ ‡ç­¾
         * @param {TagDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagDelete(body?: TagDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ ‡ç­¾é¡¹-æ·»åŠ 
         * @summary æ ‡ç­¾é¡¹-æ·»åŠ 
         * @param {TagItemCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagItemCreate(body?: TagItemCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagItemCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ ‡ç­¾é¡¹-åˆ é™¤
         * @summary æ ‡ç­¾é¡¹-åˆ é™¤
         * @param {TagItemDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagItemDelete(body?: TagItemDeleteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagItemDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ! `ä½¿ç”¨äº† PostgreSQL ä¸“æœ‰çš„è¯­æ³•, ä¸æ”¯æŒæµ‹è¯•ç¯å¢ƒ` tag_id: æ ‡ç­¾ID sorted: æ’å¥½åºçš„æ ‡ç­¾é¡¹IDæ•°ç»„, å¦‚ [1326156906414215168, 1326179034668732416, 1326178972534312960]
         * @summary æ ‡ç­¾é¡¹-æ‹–æ‹½æ’åº
         * @param {TagItemDragSortRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagItemDragSort(body?: TagItemDragSortRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagItemDragSort(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ ‡ç­¾é¡¹-ç¼–è¾‘
         * @summary æ ‡ç­¾é¡¹-ç¼–è¾‘
         * @param {TagItemUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagItemUpdate(body?: TagItemUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagItemUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æŸ¥è¯¢æ ‡ç­¾
         * @summary æŸ¥è¯¢æ ‡ç­¾
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagQuery(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagQuery(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ›´æ–°æ ‡ç­¾
         * @summary æ›´æ–°æ ‡ç­¾
         * @param {TagUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagUpdate(body?: TagUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * è·³è½¬åˆ°è®¾è®¡å·¥å…·è‡ªåŠ¨ç™»å½•éœ€è¦çš„ä¿¡æ¯
         * @summary è·³è½¬åˆ°è®¾è®¡å·¥å…·è‡ªåŠ¨ç™»å½•éœ€è¦çš„ä¿¡æ¯
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDesignToken(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDesignToken(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ç™»å½•
         * @summary ç™»å½•
         * @param {Login} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLogin(body?: Login, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLogin(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * é€€å‡ºç™»å½•
         * @summary é€€å‡ºç™»å½•
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLogout(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLogout(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * åˆ·æ–°Token
         * @summary åˆ·æ–°Token
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRefreshToken(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRefreshToken(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ³¨å†Œ
         * @summary æ³¨å†Œ
         * @param {UserRegisterRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRegister(body?: UserRegisterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRegister(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * é‡ç½®å¯†ç 
         * @summary é‡ç½®å¯†ç 
         * @param {UserResetPasswordRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userResetPassword(body?: UserResetPasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userResetPassword(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * å‘é€éªŒè¯ç 
         * @summary å‘é€éªŒè¯ç 
         * @param {UserSendCaptchaRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSendCaptcha(body?: UserSendCaptchaRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSendCaptcha(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * æ›´æ–°ç”¨æˆ·ä¿¡æ¯
         * @summary æ›´æ–°ç”¨æˆ·ä¿¡æ¯
         * @param {UserUpdateProfileRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUpdateProfile(body?: UserUpdateProfileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdateProfile(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ç»é”€å•†çš„ä¸Šä¼ è·¯å¾„ä¸º `/user/${uid}/_*` ç®¡ç†å‘˜çš„ä¸Šä¼ è·¯å¾„ä¸º `/static/_*` å’Œ `/user/${uid}/_*`
         * @summary è·å–ç”¨äºå‰ç«¯ç›´ä¼ è·å–æœåŠ¡ç«¯ç­¾åæˆ–ä¸´æ—¶å¯†é’¥
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUploadCredential(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUploadCredential(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * æ‰¹é‡æ·»åŠ æˆªé¢
         * @summary æ‰¹é‡æ·»åŠ æˆªé¢
         * @param {D2ModelCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d2ModelCreate(body?: D2ModelCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.d2ModelCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ é™¤æˆªé¢
         * @summary åˆ é™¤æˆªé¢
         * @param {D2ModelDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d2ModelDelete(body?: D2ModelDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.d2ModelDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æŸ¥è¯¢æˆªé¢
         * @summary æŸ¥è¯¢æˆªé¢
         * @param {D2ModelQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d2ModelQuery(body?: D2ModelQueryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.d2ModelQuery(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ›´æ–°æˆªé¢
         * @summary æ›´æ–°æˆªé¢
         * @param {D2ModelUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d2ModelUpdate(body?: D2ModelUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.d2ModelUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ‰¹é‡æ·»åŠ 3Dæ¨¡å‹
         * @summary æ‰¹é‡æ·»åŠ 3Dæ¨¡å‹
         * @param {D3ModelCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d3ModelCreate(body?: D3ModelCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.d3ModelCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ é™¤3Dæ¨¡å‹
         * @summary åˆ é™¤3Dæ¨¡å‹
         * @param {D3ModelDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d3ModelDelete(body?: D3ModelDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.d3ModelDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æŸ¥è¯¢3Dæ¨¡å‹
         * @summary æŸ¥è¯¢3Dæ¨¡å‹
         * @param {D3ModelQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d3ModelQuery(body?: D3ModelQueryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.d3ModelQuery(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ›´æ–°3Dæ¨¡å‹
         * @summary æ›´æ–°3Dæ¨¡å‹
         * @param {D3ModelUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d3ModelUpdate(body?: D3ModelUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.d3ModelUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ‰¹é‡æ·»åŠ æè´¨
         * @summary æ‰¹é‡æ·»åŠ æè´¨
         * @param {MaterialCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        materialCreate(body?: MaterialCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.materialCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ é™¤æè´¨
         * @summary åˆ é™¤æè´¨
         * @param {MaterialDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        materialDelete(body?: MaterialDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.materialDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ ¹æ®åç§°åˆ—è¡¨æŸ¥è¯¢æè´¨
         * @summary æ ¹æ®åç§°åˆ—è¡¨æŸ¥è¯¢æè´¨
         * @param {MaterialListByNameRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        materialListByName(body?: MaterialListByNameRequest, options?: any): AxiosPromise<void> {
            return localVarFp.materialListByName(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æŸ¥è¯¢æè´¨
         * @summary æŸ¥è¯¢æè´¨
         * @param {MaterialQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        materialQuery(body?: MaterialQueryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.materialQuery(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ›´æ–°æè´¨
         * @summary æ›´æ–°æè´¨
         * @param {MaterialUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        materialUpdate(body?: MaterialUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.materialUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ–°å»ºä¼šå‘˜å¡
         * @summary æ–°å»ºä¼šå‘˜å¡
         * @param {MemberCardCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberCardCreate(body?: MemberCardCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.memberCardCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ é™¤ä¼šå‘˜å¡
         * @summary åˆ é™¤ä¼šå‘˜å¡
         * @param {MemberCardDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberCardDelete(body?: MemberCardDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.memberCardDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æŸ¥è¯¢ä¼šå‘˜å¡ä¿¡æ¯
         * @summary æŸ¥è¯¢ä¼šå‘˜å¡ä¿¡æ¯
         * @param {MemberCardQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberCardQuery(body?: MemberCardQueryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.memberCardQuery(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ›´æ–°ä¼šå‘˜å¡
         * @summary æ›´æ–°ä¼šå‘˜å¡
         * @param {MemberCardUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberCardUpdate(body?: MemberCardUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.memberCardUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ›´æ–°ä¼šå‘˜å¡é”€å”®çŠ¶æ€
         * @summary æ›´æ–°ä¼šå‘˜å¡é”€å”®çŠ¶æ€
         * @param {MemberCardUpdateSalesStatusRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberCardUpdateSalesStatus(body?: MemberCardUpdateSalesStatusRequest, options?: any): AxiosPromise<void> {
            return localVarFp.memberCardUpdateSalesStatus(body, options).then((request) => request(axios, basePath));
        },
        /**
         * ä¼šå‘˜æŸ¥è¯¢
         * @summary ä¼šå‘˜æŸ¥è¯¢
         * @param {MemberQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberQuery(body?: MemberQueryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.memberQuery(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ–°å»ºæ¨¡å—
         * @summary æ–°å»ºæ¨¡å—
         * @param {ModuleCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleCreate(body?: ModuleCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.moduleCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ é™¤æ¨¡å—
         * @summary åˆ é™¤æ¨¡å—
         * @param {ModuleDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleDelete(body?: ModuleDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.moduleDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æŸ¥è¯¢æ¨¡å—
         * @summary æŸ¥è¯¢æ¨¡å—
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleQuery(body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.moduleQuery(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ›´æ–°æ¨¡å—çš„æ ‡ç­¾
         * @summary æ›´æ–°æ¨¡å—çš„æ ‡ç­¾
         * @param {ModuleTagsUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleTagsUpdate(body?: ModuleTagsUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.moduleTagsUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ›´æ–°æ¨¡å—
         * @summary æ›´æ–°æ¨¡å—
         * @param {ModuleUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleUpdate(body?: ModuleUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.moduleUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ–°å»ºè®¢å•
         * @summary æ–°å»ºè®¢å•
         * @param {OrderCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCreate(body?: OrderCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orderCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ é™¤è®¢å•
         * @summary åˆ é™¤è®¢å•
         * @param {OrderDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDelete(body?: OrderDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orderDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * è®¢å•åˆ—è¡¨
         * @summary è®¢å•åˆ—è¡¨
         * @param {OrderListRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderList(body?: OrderListRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orderList(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æŸ¥è¯¢å•ä¸ªè®¢å•. `ç”¨äºæ”¯ä»˜åæŸ¥è¯¢è®¢å•çŠ¶æ€`
         * @summary æŸ¥è¯¢å•ä¸ªè®¢å•. `ç”¨äºæ”¯ä»˜åæŸ¥è¯¢è®¢å•çŠ¶æ€`
         * @param {OrderQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderQuery(body?: OrderQueryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orderQuery(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ›´æ–°è®¢å•, `å½“å‰ä»…æ”¯æŒç®¡ç†å‘˜æ·»åŠ å¤‡æ³¨`
         * @summary æ›´æ–°è®¢å•, `å½“å‰ä»…æ”¯æŒç®¡ç†å‘˜æ·»åŠ å¤‡æ³¨`
         * @param {OrderUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderUpdate(body?: OrderUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orderUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ–¹æ¡ˆæŸ¥è¯¢
         * @summary æ–¹æ¡ˆæŸ¥è¯¢
         * @param {ProjectQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectQuery(body?: ProjectQueryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.projectQuery(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ–°å¢äº§å“æè´¨æŠ¥ä»·
         * @summary æ–°å¢äº§å“æè´¨æŠ¥ä»·
         * @param {QuoteMaterialCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteMaterialCreate(body?: QuoteMaterialCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.quoteMaterialCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ é™¤äº§å“æè´¨æŠ¥ä»·
         * @summary åˆ é™¤äº§å“æè´¨æŠ¥ä»·
         * @param {QuoteMaterialDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteMaterialDelete(body?: QuoteMaterialDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.quoteMaterialDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * ä¿®æ”¹äº§å“æè´¨æŠ¥ä»·
         * @summary ä¿®æ”¹äº§å“æè´¨æŠ¥ä»·
         * @param {QuoteMaterialUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteMaterialUpdate(body?: QuoteMaterialUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.quoteMaterialUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ–°å¢äº§å“å‹å·
         * @summary æ–°å¢äº§å“å‹å·
         * @param {QuoteModelCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteModelCreate(body?: QuoteModelCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.quoteModelCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ é™¤äº§å“å‹å·
         * @summary åˆ é™¤äº§å“å‹å·
         * @param {QuoteModelDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteModelDelete(body?: QuoteModelDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.quoteModelDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * ä¿®æ”¹äº§å“å‹å·
         * @summary ä¿®æ”¹äº§å“å‹å·
         * @param {QuoteModelUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteModelUpdate(body?: QuoteModelUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.quoteModelUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æŠ¥ä»·æŸ¥è¯¢
         * @summary æŠ¥ä»·æŸ¥è¯¢
         * @param {QuoteQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteQuery(body?: QuoteQueryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.quoteQuery(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ–°å¢äº§å“è§„æ ¼
         * @summary æ–°å¢äº§å“è§„æ ¼
         * @param {QuoteSpecCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteSpecCreate(body?: QuoteSpecCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.quoteSpecCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ é™¤äº§å“è§„æ ¼
         * @summary åˆ é™¤äº§å“è§„æ ¼
         * @param {QuoteSpecDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteSpecDelete(body?: QuoteSpecDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.quoteSpecDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * ä¿®æ”¹äº§å“è§„æ ¼
         * @summary ä¿®æ”¹äº§å“è§„æ ¼
         * @param {QuoteSpecUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteSpecUpdate(body?: QuoteSpecUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.quoteSpecUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ–°å»ºæ¥¼æ¢¯
         * @summary æ–°å»ºæ¥¼æ¢¯
         * @param {StairCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stairCreate(body?: StairCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.stairCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ é™¤æ¥¼æ¢¯
         * @summary åˆ é™¤æ¥¼æ¢¯
         * @param {StairDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stairDelete(body?: StairDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.stairDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ¥¼æ¢¯è¯¦æƒ…
         * @summary æ¥¼æ¢¯è¯¦æƒ…
         * @param {StairDetailRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stairDetail(body?: StairDetailRequest, options?: any): AxiosPromise<void> {
            return localVarFp.stairDetail(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æŸ¥è¯¢æ¥¼æ¢¯
         * @summary æŸ¥è¯¢æ¥¼æ¢¯
         * @param {StairQueryRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stairQuery(body?: StairQueryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.stairQuery(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ›´æ–°æ¥¼æ¢¯
         * @summary æ›´æ–°æ¥¼æ¢¯
         * @param {StairUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stairUpdate(body?: StairUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.stairUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ–°å»ºæ ‡ç­¾
         * @summary æ–°å»ºæ ‡ç­¾
         * @param {TagCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagCreate(body?: TagCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.tagCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ é™¤æ ‡ç­¾
         * @summary åˆ é™¤æ ‡ç­¾
         * @param {TagDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDelete(body?: TagDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.tagDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ ‡ç­¾é¡¹-æ·»åŠ 
         * @summary æ ‡ç­¾é¡¹-æ·»åŠ 
         * @param {TagItemCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagItemCreate(body?: TagItemCreateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.tagItemCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ ‡ç­¾é¡¹-åˆ é™¤
         * @summary æ ‡ç­¾é¡¹-åˆ é™¤
         * @param {TagItemDeleteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagItemDelete(body?: TagItemDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.tagItemDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * ! `ä½¿ç”¨äº† PostgreSQL ä¸“æœ‰çš„è¯­æ³•, ä¸æ”¯æŒæµ‹è¯•ç¯å¢ƒ` tag_id: æ ‡ç­¾ID sorted: æ’å¥½åºçš„æ ‡ç­¾é¡¹IDæ•°ç»„, å¦‚ [1326156906414215168, 1326179034668732416, 1326178972534312960]
         * @summary æ ‡ç­¾é¡¹-æ‹–æ‹½æ’åº
         * @param {TagItemDragSortRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagItemDragSort(body?: TagItemDragSortRequest, options?: any): AxiosPromise<void> {
            return localVarFp.tagItemDragSort(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ ‡ç­¾é¡¹-ç¼–è¾‘
         * @summary æ ‡ç­¾é¡¹-ç¼–è¾‘
         * @param {TagItemUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagItemUpdate(body?: TagItemUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.tagItemUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æŸ¥è¯¢æ ‡ç­¾
         * @summary æŸ¥è¯¢æ ‡ç­¾
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagQuery(body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.tagQuery(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ›´æ–°æ ‡ç­¾
         * @summary æ›´æ–°æ ‡ç­¾
         * @param {TagUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagUpdate(body?: TagUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.tagUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * è·³è½¬åˆ°è®¾è®¡å·¥å…·è‡ªåŠ¨ç™»å½•éœ€è¦çš„ä¿¡æ¯
         * @summary è·³è½¬åˆ°è®¾è®¡å·¥å…·è‡ªåŠ¨ç™»å½•éœ€è¦çš„ä¿¡æ¯
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDesignToken(body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.userDesignToken(body, options).then((request) => request(axios, basePath));
        },
        /**
         * ç™»å½•
         * @summary ç™»å½•
         * @param {Login} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(body?: Login, options?: any): AxiosPromise<void> {
            return localVarFp.userLogin(body, options).then((request) => request(axios, basePath));
        },
        /**
         * é€€å‡ºç™»å½•
         * @summary é€€å‡ºç™»å½•
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogout(body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.userLogout(body, options).then((request) => request(axios, basePath));
        },
        /**
         * åˆ·æ–°Token
         * @summary åˆ·æ–°Token
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRefreshToken(body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.userRefreshToken(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ³¨å†Œ
         * @summary æ³¨å†Œ
         * @param {UserRegisterRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegister(body?: UserRegisterRequest, options?: any): AxiosPromise<void> {
            return localVarFp.userRegister(body, options).then((request) => request(axios, basePath));
        },
        /**
         * é‡ç½®å¯†ç 
         * @summary é‡ç½®å¯†ç 
         * @param {UserResetPasswordRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userResetPassword(body?: UserResetPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.userResetPassword(body, options).then((request) => request(axios, basePath));
        },
        /**
         * å‘é€éªŒè¯ç 
         * @summary å‘é€éªŒè¯ç 
         * @param {UserSendCaptchaRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSendCaptcha(body?: UserSendCaptchaRequest, options?: any): AxiosPromise<void> {
            return localVarFp.userSendCaptcha(body, options).then((request) => request(axios, basePath));
        },
        /**
         * æ›´æ–°ç”¨æˆ·ä¿¡æ¯
         * @summary æ›´æ–°ç”¨æˆ·ä¿¡æ¯
         * @param {UserUpdateProfileRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateProfile(body?: UserUpdateProfileRequest, options?: any): AxiosPromise<void> {
            return localVarFp.userUpdateProfile(body, options).then((request) => request(axios, basePath));
        },
        /**
         * ç»é”€å•†çš„ä¸Šä¼ è·¯å¾„ä¸º `/user/${uid}/_*` ç®¡ç†å‘˜çš„ä¸Šä¼ è·¯å¾„ä¸º `/static/_*` å’Œ `/user/${uid}/_*`
         * @summary è·å–ç”¨äºå‰ç«¯ç›´ä¼ è·å–æœåŠ¡ç«¯ç­¾åæˆ–ä¸´æ—¶å¯†é’¥
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUploadCredential(body?: object, options?: any): AxiosPromise<void> {
            return localVarFp.userUploadCredential(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * æ‰¹é‡æ·»åŠ æˆªé¢
     * @summary æ‰¹é‡æ·»åŠ æˆªé¢
     * @param {D2ModelCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public d2ModelCreate(body?: D2ModelCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).d2ModelCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ é™¤æˆªé¢
     * @summary åˆ é™¤æˆªé¢
     * @param {D2ModelDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public d2ModelDelete(body?: D2ModelDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).d2ModelDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æŸ¥è¯¢æˆªé¢
     * @summary æŸ¥è¯¢æˆªé¢
     * @param {D2ModelQueryRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public d2ModelQuery(body?: D2ModelQueryRequest, options?: any) {
        return DefaultApiFp(this.configuration).d2ModelQuery(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ›´æ–°æˆªé¢
     * @summary æ›´æ–°æˆªé¢
     * @param {D2ModelUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public d2ModelUpdate(body?: D2ModelUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).d2ModelUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ‰¹é‡æ·»åŠ 3Dæ¨¡å‹
     * @summary æ‰¹é‡æ·»åŠ 3Dæ¨¡å‹
     * @param {D3ModelCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public d3ModelCreate(body?: D3ModelCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).d3ModelCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ é™¤3Dæ¨¡å‹
     * @summary åˆ é™¤3Dæ¨¡å‹
     * @param {D3ModelDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public d3ModelDelete(body?: D3ModelDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).d3ModelDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æŸ¥è¯¢3Dæ¨¡å‹
     * @summary æŸ¥è¯¢3Dæ¨¡å‹
     * @param {D3ModelQueryRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public d3ModelQuery(body?: D3ModelQueryRequest, options?: any) {
        return DefaultApiFp(this.configuration).d3ModelQuery(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ›´æ–°3Dæ¨¡å‹
     * @summary æ›´æ–°3Dæ¨¡å‹
     * @param {D3ModelUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public d3ModelUpdate(body?: D3ModelUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).d3ModelUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ‰¹é‡æ·»åŠ æè´¨
     * @summary æ‰¹é‡æ·»åŠ æè´¨
     * @param {MaterialCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public materialCreate(body?: MaterialCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).materialCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ é™¤æè´¨
     * @summary åˆ é™¤æè´¨
     * @param {MaterialDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public materialDelete(body?: MaterialDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).materialDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ ¹æ®åç§°åˆ—è¡¨æŸ¥è¯¢æè´¨
     * @summary æ ¹æ®åç§°åˆ—è¡¨æŸ¥è¯¢æè´¨
     * @param {MaterialListByNameRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public materialListByName(body?: MaterialListByNameRequest, options?: any) {
        return DefaultApiFp(this.configuration).materialListByName(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æŸ¥è¯¢æè´¨
     * @summary æŸ¥è¯¢æè´¨
     * @param {MaterialQueryRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public materialQuery(body?: MaterialQueryRequest, options?: any) {
        return DefaultApiFp(this.configuration).materialQuery(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ›´æ–°æè´¨
     * @summary æ›´æ–°æè´¨
     * @param {MaterialUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public materialUpdate(body?: MaterialUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).materialUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ–°å»ºä¼šå‘˜å¡
     * @summary æ–°å»ºä¼šå‘˜å¡
     * @param {MemberCardCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public memberCardCreate(body?: MemberCardCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).memberCardCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ é™¤ä¼šå‘˜å¡
     * @summary åˆ é™¤ä¼šå‘˜å¡
     * @param {MemberCardDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public memberCardDelete(body?: MemberCardDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).memberCardDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æŸ¥è¯¢ä¼šå‘˜å¡ä¿¡æ¯
     * @summary æŸ¥è¯¢ä¼šå‘˜å¡ä¿¡æ¯
     * @param {MemberCardQueryRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public memberCardQuery(body?: MemberCardQueryRequest, options?: any) {
        return DefaultApiFp(this.configuration).memberCardQuery(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ›´æ–°ä¼šå‘˜å¡
     * @summary æ›´æ–°ä¼šå‘˜å¡
     * @param {MemberCardUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public memberCardUpdate(body?: MemberCardUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).memberCardUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ›´æ–°ä¼šå‘˜å¡é”€å”®çŠ¶æ€
     * @summary æ›´æ–°ä¼šå‘˜å¡é”€å”®çŠ¶æ€
     * @param {MemberCardUpdateSalesStatusRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public memberCardUpdateSalesStatus(body?: MemberCardUpdateSalesStatusRequest, options?: any) {
        return DefaultApiFp(this.configuration).memberCardUpdateSalesStatus(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ä¼šå‘˜æŸ¥è¯¢
     * @summary ä¼šå‘˜æŸ¥è¯¢
     * @param {MemberQueryRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public memberQuery(body?: MemberQueryRequest, options?: any) {
        return DefaultApiFp(this.configuration).memberQuery(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ–°å»ºæ¨¡å—
     * @summary æ–°å»ºæ¨¡å—
     * @param {ModuleCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moduleCreate(body?: ModuleCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).moduleCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ é™¤æ¨¡å—
     * @summary åˆ é™¤æ¨¡å—
     * @param {ModuleDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moduleDelete(body?: ModuleDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).moduleDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æŸ¥è¯¢æ¨¡å—
     * @summary æŸ¥è¯¢æ¨¡å—
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moduleQuery(body?: object, options?: any) {
        return DefaultApiFp(this.configuration).moduleQuery(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ›´æ–°æ¨¡å—çš„æ ‡ç­¾
     * @summary æ›´æ–°æ¨¡å—çš„æ ‡ç­¾
     * @param {ModuleTagsUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moduleTagsUpdate(body?: ModuleTagsUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).moduleTagsUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ›´æ–°æ¨¡å—
     * @summary æ›´æ–°æ¨¡å—
     * @param {ModuleUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moduleUpdate(body?: ModuleUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).moduleUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ–°å»ºè®¢å•
     * @summary æ–°å»ºè®¢å•
     * @param {OrderCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderCreate(body?: OrderCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).orderCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ é™¤è®¢å•
     * @summary åˆ é™¤è®¢å•
     * @param {OrderDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderDelete(body?: OrderDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).orderDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * è®¢å•åˆ—è¡¨
     * @summary è®¢å•åˆ—è¡¨
     * @param {OrderListRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderList(body?: OrderListRequest, options?: any) {
        return DefaultApiFp(this.configuration).orderList(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æŸ¥è¯¢å•ä¸ªè®¢å•. `ç”¨äºæ”¯ä»˜åæŸ¥è¯¢è®¢å•çŠ¶æ€`
     * @summary æŸ¥è¯¢å•ä¸ªè®¢å•. `ç”¨äºæ”¯ä»˜åæŸ¥è¯¢è®¢å•çŠ¶æ€`
     * @param {OrderQueryRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderQuery(body?: OrderQueryRequest, options?: any) {
        return DefaultApiFp(this.configuration).orderQuery(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ›´æ–°è®¢å•, `å½“å‰ä»…æ”¯æŒç®¡ç†å‘˜æ·»åŠ å¤‡æ³¨`
     * @summary æ›´æ–°è®¢å•, `å½“å‰ä»…æ”¯æŒç®¡ç†å‘˜æ·»åŠ å¤‡æ³¨`
     * @param {OrderUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderUpdate(body?: OrderUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).orderUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ–¹æ¡ˆæŸ¥è¯¢
     * @summary æ–¹æ¡ˆæŸ¥è¯¢
     * @param {ProjectQueryRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectQuery(body?: ProjectQueryRequest, options?: any) {
        return DefaultApiFp(this.configuration).projectQuery(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ–°å¢äº§å“æè´¨æŠ¥ä»·
     * @summary æ–°å¢äº§å“æè´¨æŠ¥ä»·
     * @param {QuoteMaterialCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quoteMaterialCreate(body?: QuoteMaterialCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).quoteMaterialCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ é™¤äº§å“æè´¨æŠ¥ä»·
     * @summary åˆ é™¤äº§å“æè´¨æŠ¥ä»·
     * @param {QuoteMaterialDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quoteMaterialDelete(body?: QuoteMaterialDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).quoteMaterialDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ä¿®æ”¹äº§å“æè´¨æŠ¥ä»·
     * @summary ä¿®æ”¹äº§å“æè´¨æŠ¥ä»·
     * @param {QuoteMaterialUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quoteMaterialUpdate(body?: QuoteMaterialUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).quoteMaterialUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ–°å¢äº§å“å‹å·
     * @summary æ–°å¢äº§å“å‹å·
     * @param {QuoteModelCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quoteModelCreate(body?: QuoteModelCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).quoteModelCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ é™¤äº§å“å‹å·
     * @summary åˆ é™¤äº§å“å‹å·
     * @param {QuoteModelDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quoteModelDelete(body?: QuoteModelDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).quoteModelDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ä¿®æ”¹äº§å“å‹å·
     * @summary ä¿®æ”¹äº§å“å‹å·
     * @param {QuoteModelUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quoteModelUpdate(body?: QuoteModelUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).quoteModelUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æŠ¥ä»·æŸ¥è¯¢
     * @summary æŠ¥ä»·æŸ¥è¯¢
     * @param {QuoteQueryRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quoteQuery(body?: QuoteQueryRequest, options?: any) {
        return DefaultApiFp(this.configuration).quoteQuery(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ–°å¢äº§å“è§„æ ¼
     * @summary æ–°å¢äº§å“è§„æ ¼
     * @param {QuoteSpecCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quoteSpecCreate(body?: QuoteSpecCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).quoteSpecCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ é™¤äº§å“è§„æ ¼
     * @summary åˆ é™¤äº§å“è§„æ ¼
     * @param {QuoteSpecDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quoteSpecDelete(body?: QuoteSpecDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).quoteSpecDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ä¿®æ”¹äº§å“è§„æ ¼
     * @summary ä¿®æ”¹äº§å“è§„æ ¼
     * @param {QuoteSpecUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quoteSpecUpdate(body?: QuoteSpecUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).quoteSpecUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ–°å»ºæ¥¼æ¢¯
     * @summary æ–°å»ºæ¥¼æ¢¯
     * @param {StairCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stairCreate(body?: StairCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).stairCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ é™¤æ¥¼æ¢¯
     * @summary åˆ é™¤æ¥¼æ¢¯
     * @param {StairDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stairDelete(body?: StairDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).stairDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ¥¼æ¢¯è¯¦æƒ…
     * @summary æ¥¼æ¢¯è¯¦æƒ…
     * @param {StairDetailRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stairDetail(body?: StairDetailRequest, options?: any) {
        return DefaultApiFp(this.configuration).stairDetail(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æŸ¥è¯¢æ¥¼æ¢¯
     * @summary æŸ¥è¯¢æ¥¼æ¢¯
     * @param {StairQueryRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stairQuery(body?: StairQueryRequest, options?: any) {
        return DefaultApiFp(this.configuration).stairQuery(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ›´æ–°æ¥¼æ¢¯
     * @summary æ›´æ–°æ¥¼æ¢¯
     * @param {StairUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stairUpdate(body?: StairUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).stairUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ–°å»ºæ ‡ç­¾
     * @summary æ–°å»ºæ ‡ç­¾
     * @param {TagCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tagCreate(body?: TagCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).tagCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ é™¤æ ‡ç­¾
     * @summary åˆ é™¤æ ‡ç­¾
     * @param {TagDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tagDelete(body?: TagDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).tagDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ ‡ç­¾é¡¹-æ·»åŠ 
     * @summary æ ‡ç­¾é¡¹-æ·»åŠ 
     * @param {TagItemCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tagItemCreate(body?: TagItemCreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).tagItemCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ ‡ç­¾é¡¹-åˆ é™¤
     * @summary æ ‡ç­¾é¡¹-åˆ é™¤
     * @param {TagItemDeleteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tagItemDelete(body?: TagItemDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).tagItemDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ! `ä½¿ç”¨äº† PostgreSQL ä¸“æœ‰çš„è¯­æ³•, ä¸æ”¯æŒæµ‹è¯•ç¯å¢ƒ` tag_id: æ ‡ç­¾ID sorted: æ’å¥½åºçš„æ ‡ç­¾é¡¹IDæ•°ç»„, å¦‚ [1326156906414215168, 1326179034668732416, 1326178972534312960]
     * @summary æ ‡ç­¾é¡¹-æ‹–æ‹½æ’åº
     * @param {TagItemDragSortRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tagItemDragSort(body?: TagItemDragSortRequest, options?: any) {
        return DefaultApiFp(this.configuration).tagItemDragSort(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ ‡ç­¾é¡¹-ç¼–è¾‘
     * @summary æ ‡ç­¾é¡¹-ç¼–è¾‘
     * @param {TagItemUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tagItemUpdate(body?: TagItemUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).tagItemUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æŸ¥è¯¢æ ‡ç­¾
     * @summary æŸ¥è¯¢æ ‡ç­¾
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tagQuery(body?: object, options?: any) {
        return DefaultApiFp(this.configuration).tagQuery(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ›´æ–°æ ‡ç­¾
     * @summary æ›´æ–°æ ‡ç­¾
     * @param {TagUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tagUpdate(body?: TagUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).tagUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * è·³è½¬åˆ°è®¾è®¡å·¥å…·è‡ªåŠ¨ç™»å½•éœ€è¦çš„ä¿¡æ¯
     * @summary è·³è½¬åˆ°è®¾è®¡å·¥å…·è‡ªåŠ¨ç™»å½•éœ€è¦çš„ä¿¡æ¯
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userDesignToken(body?: object, options?: any) {
        return DefaultApiFp(this.configuration).userDesignToken(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ç™»å½•
     * @summary ç™»å½•
     * @param {Login} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userLogin(body?: Login, options?: any) {
        return DefaultApiFp(this.configuration).userLogin(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * é€€å‡ºç™»å½•
     * @summary é€€å‡ºç™»å½•
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userLogout(body?: object, options?: any) {
        return DefaultApiFp(this.configuration).userLogout(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * åˆ·æ–°Token
     * @summary åˆ·æ–°Token
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRefreshToken(body?: object, options?: any) {
        return DefaultApiFp(this.configuration).userRefreshToken(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ³¨å†Œ
     * @summary æ³¨å†Œ
     * @param {UserRegisterRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRegister(body?: UserRegisterRequest, options?: any) {
        return DefaultApiFp(this.configuration).userRegister(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * é‡ç½®å¯†ç 
     * @summary é‡ç½®å¯†ç 
     * @param {UserResetPasswordRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userResetPassword(body?: UserResetPasswordRequest, options?: any) {
        return DefaultApiFp(this.configuration).userResetPassword(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * å‘é€éªŒè¯ç 
     * @summary å‘é€éªŒè¯ç 
     * @param {UserSendCaptchaRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSendCaptcha(body?: UserSendCaptchaRequest, options?: any) {
        return DefaultApiFp(this.configuration).userSendCaptcha(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * æ›´æ–°ç”¨æˆ·ä¿¡æ¯
     * @summary æ›´æ–°ç”¨æˆ·ä¿¡æ¯
     * @param {UserUpdateProfileRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userUpdateProfile(body?: UserUpdateProfileRequest, options?: any) {
        return DefaultApiFp(this.configuration).userUpdateProfile(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ç»é”€å•†çš„ä¸Šä¼ è·¯å¾„ä¸º `/user/${uid}/_*` ç®¡ç†å‘˜çš„ä¸Šä¼ è·¯å¾„ä¸º `/static/_*` å’Œ `/user/${uid}/_*`
     * @summary è·å–ç”¨äºå‰ç«¯ç›´ä¼ è·å–æœåŠ¡ç«¯ç­¾åæˆ–ä¸´æ—¶å¯†é’¥
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userUploadCredential(body?: object, options?: any) {
        return DefaultApiFp(this.configuration).userUploadCredential(body, options).then((request) => request(this.axios, this.basePath));
    }
}


